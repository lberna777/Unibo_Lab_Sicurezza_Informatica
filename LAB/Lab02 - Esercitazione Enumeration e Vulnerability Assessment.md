# **Relazione di Laboratorio: Vulnerability Assessment ed Enumeration**

**Corso:** Laboratorio di Sicurezza Informatica  
**Obiettivo:** Condurre una simulazione di attacco partendo dalla ricognizione (Reconnaissance/Enumeration) fino all'ottenimento degli accessi (Brute-forcing online e offline), unendo concetti teorici di reti IP all'utilizzo pratico di tool offensivi.

## **Fase 1: Predisposizione dell'Ambiente (Target)**

Il primo passo di ogni attività di offensive security in ambiente di laboratorio è la configurazione sicura dei target.  
**Azione Pratica:**

1. Tramite Oracle VM VirtualBox, creare tre macchine virtuali utilizzando i dischi preesistenti (Appliance-disk001.vdi, 002, 003).  
2. Configurare ciascuna VM con: Sistema Linux (Debian 64-bit), 1 CPU, 1024 MB di RAM.  
3. Impostare la scheda di rete in modalità **"Host-only"** (es. collegata a vboxnet0).  
4. **Scattare uno snapshot** prima di avviare le macchine.

**Approfondimento Teorico:**

* **Perché "Host-only"?** La rete Host-only crea una LAN (Local Area Network) virtuale isolata dal mondo esterno. In questo modo le macchine bersaglio non sono esposte a Internet, ma possono comunicare con la nostra macchina attaccante (es. Parrot/Kali Linux).  
* In questa subnet, il server DHCP di VirtualBox assegnerà un indirizzo IPv4 (es. nel range 192.168.56.0/24) a ciascuna macchina.  
* **Lo Snapshot:** Essenziale per la ripetibilità dell'esperimento. Qualsiasi alterazione del file system durante l'attacco potrà essere annullata ripristinando lo snapshot iniziale.

## **Fase 2: Host Discovery (Scoperta degli Host)**

Non sapendo quali indirizzi IP abbiano assunto le macchine bersaglio tramite il DHCP, dobbiamo scansionare l'intera sottorete.  
**Azione Pratica:**  
Dal terminale della macchina attaccante, lanciare il comando:  
nmap \-sn 192.168.56.0/24

*Supponiamo che l'output riveli tre host attivi: 192.168.56.32, .33 e .34.*  
**Approfondimento Teorico:**

* **Indirizzamento IP e CIDR:** La notazione /24 (Classless Inter-Domain Routing \- CIDR) indica che i primi 24 bit dell'indirizzo identificano la rete, lasciando 8 bit per gli host (per un totale di 256 indirizzi, di cui 254 assegnabili). Il comando interroga l'intero blocco.  
* **Il parametro \-sn (Ping Scan):** Istruisce nmap a *non* effettuare la scansione delle porte, ma solo a verificare quali host sono "vivi".  
* **Il protocollo ARP:** Poiché ci troviamo sulla stessa rete locale (LAN) dei bersagli, nmap non usa i classici pacchetti ICMP Echo Request, ma sfrutta l'**ARP (Address Resolution Protocol)**. Invia richieste in broadcast ("*Who has 192.168.56.32?*") e attende le risposte contenenti i MAC Address, un metodo infallibile per reti locali, aggirando eventuali firewall che bloccano i ping.

## **Fase 3: Enumerazione dei Servizi e delle Porte**

Una volta individuati gli IP, dobbiamo scoprire quali servizi ("porte aperte") espongono alla rete.  
**Azione Pratica:**  
Una prima scansione di base (limitata alle porte TCP standard):  
nmap \-sT 192.168.56.32-34

Tuttavia, questa scansione ha dei **limiti**: non esplora tutte le porte e non verifica se il servizio risponde al vero. Passiamo quindi a una **scansione approfondita**:  
nmap \-sV 192.168.56.32-34 \-p-

**Risultati Notevoli (dalla scansione \-sV):**

* **Host .32:** Standard (SSH su 22, HTTP su 80, MySQL su 3306, PostgreSQL su 5432).  
* **Host .33:** Oltre ai servizi di posta (SMTP, POP3, IMAP), mostra la porta **1337** aperta. Nmap riconosce che lì *non* c'è un servizio fittizio ("waste"), ma un demone **OpenSSH**.  
* **Host .34:** Mostra server web su porte insolite (8000 sconosciuta, 8001 server Werkzeug Python).

**Approfondimento Teorico:**

* **Well-known ports vs Custom ports:** I servizi standard usano porte definite dalla IANA (es. SSH sulla 22, HTTP sulla 80). Tuttavia, per *Security through obscurity* (sicurezza tramite oscurità), un amministratore potrebbe spostare un servizio come SSH su una porta alta come la 1337\.  
* **Nmap \-sV (Version Detection):** Questo flag è cruciale. Nmap non si limita a verificare se il protocollo TCP completa l'handshake, ma invia "probe" (esche) al servizio e ne analizza il "banner" di risposta per dedurre con esattezza quale applicazione è in ascolto e in quale versione.  
* *Nota per l'automazione:* In scenari reali complessi, i risultati di Nmap vengono dati in pasto a piattaforme di Vulnerability Assessment come **Greenbone Security Assistant (OpenVAS)**, che incrociano automaticamente le versioni scoperte (es. *Apache 2.4.65*) con i database delle vulnerabilità note (CVE).

## **Fase 4: Sfruttamento delle Misconfigurazioni**

L'enumerazione rivela spesso servizi che non dovrebbero essere esposti, o che offrono troppe informazioni.  
**Azione Pratica:**

1. **Interrogazione SMTP (Host .33):**  
   I server di posta (porta 25\) accettano per natura connessioni esterne. Usiamo nc (Netcat) per parlare direttamente col server:  
   nc 192.168.56.33 25

   *Questo permette di leggere il banner e, se non disabilitati, usare comandi come VRFY per enumerare utenti validi del sistema.*  
2. **Accesso a Database (Host .32):**  
   Nmap ha trovato PostgreSQL aperto. I database non dovrebbero mai essere esposti fuori dalla rete locale o dalla rete applicativa. Usiamo il client nativo per connetterci:  
   psql \-U admin \-h 192.168.56.32 \-W accounts\_db

   Una volta ottenuto l'accesso (magari per password di default), possiamo enumerare le tabelle con \\dt ed esfiltrare dati sensibili:  
   SELECT \* FROM accounts;

**Approfondimento Teorico:**  
Nmap trova la "porta", ma l'esplorazione deve essere fatta con tool interattivi. Netcat (nc) apre una semplice connessione TCP/IP pura. I client nativi (psql, smbclient) implementano correttamente il protocollo applicativo per permetterci di estrarre dati strutturati.

## **Fase 5: Brute Forcing Online (Accesso al Sistema)**

Avendo estratto credenziali dai database o tramite OSINT, si cerca di ottenere un accesso shell (tramite SSH).  
**Azione Pratica:**  
Supponiamo di aver trovato un appunto interno (/home/turing/note.txt) che recita: *"Reminder: to get full control of t-2, use your 4-digit pin"*. Sapendo che t-2 è l'host .33 e che SSH è esposto sulla porta 1337, lanciamo un attacco a forza bruta usando hydra:  
hydra \-l root \-x 4:4:1 ssh://192.168.56.33:1337

**Approfondimento Teorico:**

* **Guessing vs Brute Forcing:** Il guessing utilizza liste di nomi noti (wordlists come *rockyou.txt*). Il brute forcing, invece, tenta iterativamente tutte le combinazioni possibili di un alfabeto.  
* **La sintassi di Hydra:** Il parametro \-x 4:4:1 ordina ad Hydra di generare password al volo: lunghezza minima 4, lunghezza massima 4, usando l'alfabeto "1" (che corrisponde ai numeri da 0 a 9). Stiamo provando tutti i PIN da 0000 a 9999\.  
* **Limiti dell'attacco Online:** L'attacco verso un servizio di rete (online) è lento (influenzato dalla latenza e dalle difese del servizio) e molto rumoroso (genera migliaia di log nei sistemi IDS/IPS).

## **Fase 6: Hash Cracking Offline**

Se durante l'esplorazione (es. tramite una misconfigurazione web o file condivisi) entriamo in possesso dei file passwd.bak e shadow.bak, possiamo attaccare le password offline, che è infinitamente più veloce.  
**Azione Pratica:**

1. **Creazione Wordlist Custom:** Usando il tool **CUPP** (Common User Passwords Profiler), inseriamo le informazioni base scoperte sugli utenti (es. nomi estratti dal database, anni di nascita) per generare un dizionario altamente mirato.  
   python3 cupp.py \-i

2. **Cracking con John The Ripper:** Usiamo "John" sui file hash catturati combinandolo con la nostra wordlist appena creata:  
   john \--format=crypt \-w=custom\_wordlist.txt shadow.bak

**Approfondimento Teorico:**

* **Architettura delle Password Linux:** Linux non salva mai le password in chiaro, ma ne conserva l'impronta (hash) nel file /etc/shadow (leggibile solo da root).  
* **Il Salt:** Per evitare attacchi tramite tabelle pre-calcolate (Rainbow Tables) o riconoscere se due utenti hanno la stessa password, Linux aggiunge un "Salt" (una stringa casuale) prima del calcolo dell'hash ($id\_algoritmo$salt$hash).  
* **Il vantaggio dell'Offline:** Poiché possediamo il file, l'attacco non passa per la rete. "John The Ripper" esegue autonomamente l'algoritmo di hash combinando il Salt trovato nel file con le parole del nostro dizionario, verificando le corrispondenze. La velocità è limitata esclusivamente dalla potenza di calcolo della nostra CPU/GPU (anche milioni di tentativi al secondo). Nelle sue varie modalità, John può procedere in *Single mode* (usando i nomi utente come base), *Wordlist mode* o *Incremental mode* (Brute force puro).

**Conclusione:** Questa simulazione dimostra l'efficacia della Unified Kill Chain: partendo dall'enumerazione esterna di indirizzi IP, sfruttando i servizi misconfigurati, per arrivare all'escalation dei privilegi tramite cracking offline delle credenziali.
